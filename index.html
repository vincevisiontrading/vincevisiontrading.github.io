<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>vincevision trading by vincent omondi</title> <style> @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;700&display=swap'); body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; transition: all 0.3s ease; } h1, h2 { font-weight: 700; color: #0078d4; /* Microsoft-inspired blue */ } #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button { padding: 10px 20px; margin: 5px; background-color: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease; } button:hover { background-color: #005a9e; } label { display: block; margin-top: 10px; font-weight: 600; } input, select { padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px; width: 100%; max-width: 300px; } /* Animation for popping in numbers/logs */ @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } } .log-entry { animation: popIn 0.5s ease-in-out; } .digit { display: inline-block; font-weight: bold; color: #0078d4; animation: popIn 0.5s ease-in-out, fadeOut 2s ease-in-out 1s forwards; } @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; } } /* Shake animation for loss */ @keyframes shake { 0% { transform: translateX(0); } 10% { transform: translateX(-10px); } 20% { transform: translateX(10px); } 30% { transform: translateX(-10px); } 40% { transform: translateX(10px); } 50% { transform: translateX(-10px); } 60% { transform: translateX(10px); } 70% { transform: translateX(-10px); } 80% { transform: translateX(10px); } 90% { transform: translateX(-10px); } 100% { transform: translateX(0); } } .shake { animation: shake 0.5s; } /* Confetti container */ #confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 9999; } .confetti { position: absolute; width: 10px; height: 10px; background-color: green; opacity: 0.8; animation: confettiFall 3s linear forwards; } @keyframes confettiFall { 0% { transform: translateY(-100%) rotate(0deg); } 100% { transform: translateY(100vh) rotate(360deg); } } </style> </head> <body> <h1>vincevision trading by vincent omondi</h1> <p>This site auto-trades only Digits Differs using selectable sniper strategies on synthetic markets (see logs for details).</p> <label for="apiToken">API Token:</label> <input type="text" id="apiToken" placeholder="Your Deriv API Token" value="1jn9NhwnKT1Gt53"> <label for="appId">App ID:</label> <input type="text" id="appId" placeholder="Your Deriv App ID" value="107513"> <label for="symbol">Synthetic Market (Symbol):</label> <select id="symbol"> <option value="R_10">Volatility 10 (R_10)</option> <option value="R_25">Volatility 25 (R_25)</option> <option value="R_50">Volatility 50 (R_50)</option> <option value="R_75">Volatility 75 (R_75)</option> <option value="R_100">Volatility 100 (R_100)</option> <option value="1HZ500V">Boom 500 (1HZ500V)</option> <option value="1HZ1000V">Crash 1000 (1HZ1000V)</option> <option value="1HZ10V">Volatility 10 (1s) (1HZ10V)</option> <option value="1HZ25V">Volatility 25 (1s) (1HZ25V)</option> <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option> <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option> <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option> <!-- Add more symbols as needed from Deriv API docs --> </select> <label for="strategy">Sniper Strategy:</label> <select id="strategy"> <option value="consecutive">Consecutive Digit Evasion</option> <option value="rare">Rare Digit Sniper</option> <option value="parity">Parity Flip Sniper</option> <option value="momentum">Momentum Break Sniper</option> </select> <label for="stake">Stake Amount (per trade):</label> <input type="number" id="stake" value="1" min="0.35" step="0.01"> <label for="duration">Duration (ticks, 1-10):</label> <input type="number" id="duration" value="5" min="1" max="10"> <button onclick="connectToAPI()">Connect to Deriv API</button> <button onclick="startAutoTrading()">Start Auto-Trading</button> <button onclick="stopAutoTrading()">Stop Auto-Trading</button> <h2>Account Balance: <span id="balance">Not connected</span></h2> <h2>Trade Log</h2> <div id="log"></div> <div id="confetti-container"></div> <script> let ws; // WebSocket connection let autoTradeInterval; // Interval for auto-trading const logElement = document.getElementById('log'); const balanceElement = document.getElementById('balance'); const confettiContainer = document.getElementById('confetti-container'); let tickHistory = []; // Last 10 ticks' last digits let pendingProposalId = null; // To handle proposal → buy // Function to log messages with animation function log(message) { const p = document.createElement('p'); p.classList.add('log-entry'); p.innerHTML = `${new Date().toLocaleTimeString()}: ${message}`; // Enhance digits in the message to pop in and disappear if (message.includes('Recent digits:')) { const parts = message.split('Recent digits: '); p.innerHTML = `${new Date().toLocaleTimeString()}: ${parts[0]}Recent digits: `; parts[1].split(', ').forEach(digit => { const span = document.createElement('span'); span.classList.add('digit'); span.textContent = digit + ' '; p.appendChild(span); }); } logElement.appendChild(p); logElement.scrollTop = logElement.scrollHeight; } // Connect to Deriv WebSocket API function connectToAPI() { const apiToken = document.getElementById('apiToken').value; const appId = document.getElementById('appId').value; const selectedSymbol = document.getElementById('symbol').value; if (!apiToken || !appId) { log('Error: Please enter API Token and App ID.'); return; } ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=' + appId); ws.onopen = () => { log('WebSocket connected.'); // Authorize with API token ws.send(JSON.stringify({ authorize: apiToken })); }; ws.onmessage = (event) => { const data = JSON.parse(event.data); if (data.error) { log('Error: ' + data.error.message); } else if (data.authorize) { log('Authorized successfully. Account: ' + data.authorize.loginid); // Subscribe to balance updates ws.send(JSON.stringify({ balance: 1, subscribe: 1 })); // Subscribe to tick stream for the selected symbol log(`Subscribing to ticks for symbol: ${selectedSymbol}`); ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 })); } else if (data.balance) { balanceElement.textContent = `${data.balance.balance} ${data.balance.currency}`; } else if (data.tick) { // Collect last digit from tick stream const lastDigit = parseInt(data.tick.quote.toString().slice(-1)); tickHistory.push(lastDigit); if (tickHistory.length > 10) tickHistory.shift(); // Keep only last 10 log(`New tick on ${data.tick.symbol}: Last digit ${lastDigit}. Recent digits: ${tickHistory.join(', ')}`); } else if (data.proposal) { // Received proposal, now buy the contract pendingProposalId = data.proposal.id; ws.send(JSON.stringify({ buy: pendingProposalId, price: data.proposal.ask_price })); } else if (data.buy) { log('Trade placed: Contract ID ' + data.buy.contract_id + ' | Buy Price: ' + data.buy.buy_price); // Subscribe to contract updates ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 })); } else if (data.proposal_open_contract) { if (data.proposal_open_contract.is_sold) { const isWin = data.proposal_open_contract.profit > 0; log('Contract closed: ' + (isWin ? 'Win' : 'Loss') + ' | Profit: ' + data.proposal_open_contract.profit); if (isWin) { showConfetti(); } else { shakeScreen(); } } } }; ws.onclose = () => { log('WebSocket disconnected.'); balanceElement.textContent = 'Disconnected'; }; ws.onerror = (error) => { log('WebSocket error: ' + error); }; } // Function to show green confetti function showConfetti() { for (let i = 0; i < 100; i++) { const confetti = document.createElement('div'); confetti.classList.add('confetti'); confetti.style.left = `${Math.random() * 100}vw`; confetti.style.animationDuration = `${Math.random() * 2 + 2}s`; confetti.style.backgroundColor = `hsl(${Math.random() * 60 + 100}, 100%, 50%)`; // Shades of green confettiContainer.appendChild(confetti); setTimeout(() => confetti.remove(), 3000); } } // Function to shake the screen function shakeScreen() { document.body.classList.add('shake'); setTimeout(() => document.body.classList.remove('shake'), 500); } // Helper: Get frequency map of digits function getDigitFreq() { const freq = {}; tickHistory.forEach(d => { freq[d] = (freq[d] || 0) + 1; }); return freq; } // Multi-Strategy Logic: Returns the digit to differ from based on selected strategy function getStrategyDigit(selectedStrategy) { if (tickHistory.length < 2) { const randomDigit = Math.floor(Math.random() * 10); log(`Insufficient tick history for ${selectedStrategy}. Defaulting to random digit: ${randomDigit}`); return randomDigit; } const freq = getDigitFreq(); switch (selectedStrategy) { case 'consecutive': // Consecutive Digit Evasion const prevDigit = tickHistory[tickHistory.length - 2]; const lastDigitC = tickHistory[tickHistory.length - 1]; let predictedDigit; if (lastDigitC === prevDigit + 1 || lastDigitC === prevDigit - 1) { const direction = lastDigitC > prevDigit ? 1 : -1; predictedDigit = (lastDigitC + direction + 10) % 10; log(`Consecutive Evasion: Pair (${prevDigit}, ${lastDigitC}). Predicting ${predictedDigit}. Differ from it.`); return predictedDigit; } else { // Fallback to most frequent let maxFreq = 0, chosen = 0; for (let d = 0; d <= 9; d++) { if (freq[d] > maxFreq || (freq[d] === maxFreq && d > chosen)) { maxFreq = freq[d]; chosen = d; } } log(`Consecutive Evasion: No pair. Most frequent ${chosen} (freq ${maxFreq}). Differ from it.`); return chosen; } case 'rare': // Rare Digit Sniper: Differ from least frequent digit let minFreq = Infinity, rareDigit = 0; for (let d = 0; d <= 9; d++) { const f = freq[d] || 0; if (f < minFreq || (f === minFreq && d < rareDigit)) { minFreq = f; rareDigit = d; } } log(`Rare Sniper: Least frequent digit ${rareDigit} (freq ${minFreq}). Differ from it.`); return rareDigit; case 'parity': // Parity Flip Sniper: If last two same parity, differ from most frequent in opposite parity const lastTwoParity = tickHistory.slice(-2).map(d => d % 2); const sameParity = lastTwoParity[0] === lastTwoParity[1]; if (sameParity) { const targetParity = 1 - lastTwoParity[1]; // Flip (0 even -> 1 odd, vice versa) let maxFreqP = 0, chosenP = targetParity === 0 ? 0 : 1; // Start with lowest in parity for (let d = targetParity; d <= 9; d += 2) { const f = freq[d] || 0; if (f > maxFreqP || (f === maxFreqP && d > chosenP)) { maxFreqP = f; chosenP = d; } } log(`Parity Flip: Last two ${lastTwoParity[1] === 0 ? 'even' : 'odd'}. Flip to ${targetParity === 0 ? 'even' : 'odd'}, most freq ${chosenP} (freq ${maxFreqP}). Differ from it.`); return chosenP; } else { // Fallback to random const randomP = Math.floor(Math.random() * 10); log(`Parity Flip: Mixed parity. Default to random ${randomP}. Differ from it.`); return randomP; } case 'momentum': // Momentum Break Sniper: Detect increasing/decreasing in last 3, differ from next if (tickHistory.length < 3) { const randomM = Math.floor(Math.random() * 10); log(`Momentum Break: Need 3 ticks. Default to random ${randomM}.`); return randomM; } const lastThree = tickHistory.slice(-3); const diff1 = lastThree[1] - lastThree[0]; const diff2 = lastThree[2] - lastThree[1]; if (diff1 === diff2 && diff1 !== 0) { // Consistent momentum (e.g., +1 each time) const predictedM = (lastThree[2] + diff2 + 10) % 10; log(`Momentum Break: Sequence ${lastThree.join('-')} (diff ${diff1}). Predicting break from ${predictedM}. Differ from it.`); return predictedM; } else { // Fallback to average digit const avg = Math.floor(tickHistory.reduce((a, b) => a + b, 0) / tickHistory.length); log(`Momentum Break: No consistent momentum. Average digit ${avg}. Differ from it.`); return avg; } default: return Math.floor(Math.random() * 10); // Fallback } } // Function to place a Differs trade based on strategy function placeTrade() { if (!ws || ws.readyState !== WebSocket.OPEN) { log('Error: Not connected to API.'); return; } const stake = parseFloat(document.getElementById('stake').value); const duration = parseInt(document.getElementById('duration').value); const selectedSymbol = document.getElementById('symbol').value; const selectedStrategy = document.getElementById('strategy').value; const evasionDigit = getStrategyDigit(selectedStrategy); // Check balance const currentBalance = parseFloat(balanceElement.textContent.split(' ')[0]); if (currentBalance < stake * 1.1) { // Buffer for safety log('Error: Insufficient balance for stake.'); return; } const tradeParams = { proposal: 1, amount: stake, basis: 'stake', contract_type: 'DIGITDIFF', // Only Differs currency: 'USD', // Change to your account currency duration: duration, duration_unit: 't', // ticks symbol: selectedSymbol, // Dynamic symbol barrier: evasionDigit.toString() // Digit to differ from }; log(`Placing Differs trade on ${selectedSymbol} for digit ${evasionDigit} (${selectedStrategy} strategy, ${duration} ticks, stake ${stake})...`); ws.send(JSON.stringify(tradeParams)); } // Start auto-trading every 60 seconds function startAutoTrading() { if (autoTradeInterval) { log('Auto-trading already running.'); return; } placeTrade(); // Initial trade autoTradeInterval = setInterval(placeTrade, 60000); // Every 60 seconds (adjust for faster markets) const selectedStrategy = document.getElementById('strategy').value; log(`Auto-trading started with ${selectedStrategy} Sniper Strategy on selected symbol.`); } // Stop auto-trading function stopAutoTrading() { if (autoTradeInterval) { clearInterval(autoTradeInterval); autoTradeInterval = null; log('Auto-trading stopped.'); } } </script> </body> </html>
        <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option>

        <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option>

        <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option>

        <!-- Add more symbols as needed from Deriv API docs -->

    </select>

    

    <label for="stake">Stake Amount (per trade):</label>

    <input type="number" id="stake" value="1" min="0.35" step="0.01">

    

    <label for="duration">Duration (ticks, 1-10):</label>

    <input type="number" id="duration" value="5" min="1" max="10">

    

    <button onclick="connectToAPI()">Connect to Deriv API</button>

    <button onclick="startAutoTrading()">Start Auto-Trading</button>

    <button onclick="stopAutoTrading()">Stop Auto-Trading</button>

    

    <h2>Account Balance: <span id="balance">Not connected</span></h2>

    <h2>Trade Log</h2>

    <div id="log"></div>


    <script>

        let ws; // WebSocket connection

        let autoTradeInterval; // Interval for auto-trading

        const logElement = document.getElementById('log');

        const balanceElement = document.getElementById('balance');

        let tickHistory = []; // Last 10 ticks' last digits

        let pendingProposalId = null; // To handle proposal → buy


        // Function to log messages

        function log(message) {

            logElement.innerHTML += `<p>${new Date().toLocaleTimeString()}: ${message}</p>`;

            logElement.scrollTop = logElement.scrollHeight;

        }


        // Connect to Deriv WebSocket API

        function connectToAPI() {

            const apiToken = document.getElementById('apiToken').value;

            const appId = document.getElementById('appId').value;

            const selectedSymbol = document.getElementById('symbol').value;


            if (!apiToken || !appId) {

                log('Error: Please enter API Token and App ID.');

                return;

            }


            ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=' + appId);


            ws.onopen = () => {

                log('WebSocket connected.');

                // Authorize with API token

                ws.send(JSON.stringify({ authorize: apiToken }));

            };


            ws.onmessage = (event) => {

                const data = JSON.parse(event.data);

                if (data.error) {

                    log('Error: ' + data.error.message);

                } else if (data.authorize) {

                    log('Authorized successfully. Account: ' + data.authorize.loginid);

                    // Subscribe to balance updates

                    ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

                    // Subscribe to tick stream for the selected symbol

                    log(`Subscribing to ticks for symbol: ${selectedSymbol}`);

                    ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 }));

                } else if (data.balance) {

                    balanceElement.textContent = `${data.balance.balance} ${data.balance.currency}`;

                } else if (data.tick) {

                    // Collect last digit from tick stream

                    const lastDigit = parseInt(data.tick.quote.toString().slice(-1));

                    tickHistory.push(lastDigit);

                    if (tickHistory.length > 10) tickHistory.shift(); // Keep only last 10

                    log(`New tick on ${data.tick.symbol}: Last digit ${lastDigit}. Recent digits: ${tickHistory.join(', ')}`);

                } else if (data.proposal) {

                    // Received proposal, now buy the contract

                    pendingProposalId = data.proposal.id;

                    ws.send(JSON.stringify({ buy: pendingProposalId, price: data.proposal.ask_price }));

                } else if (data.buy) {

                    log('Trade placed: Contract ID ' + data.buy.contract_id + ' | Buy Price: ' + data.buy.buy_price);

                    // Subscribe to contract updates

                    ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 }));

                } else if (data.proposal_open_contract) {

                    if (data.proposal_open_contract.is_sold) {

                        log('Contract closed: ' + (data.proposal_open_contract.profit > 0 ? 'Win' : 'Loss') + ' | Profit: ' + data.proposal_open_contract.profit);

                    }

                }

            };


            ws.onclose = () => {

                log('WebSocket disconnected.');

                balanceElement.textContent = 'Disconnected';

            };


            ws.onerror = (error) => {

                log('WebSocket error: ' + error);

            };

        }


        // New Custom Strategy: Consecutive Digit Evasion - Detect two consecutive digits and evade the next in sequence

        function getStrategyDigit() {

            if (tickHistory.length < 2) {

                // Not enough history, default to random

                const randomDigit = Math.floor(Math.random() * 10);

                log(`Insufficient tick history. Defaulting to differ from random digit: ${randomDigit}`);

                return randomDigit;

            }


            // Get the last two digits

            const prevDigit = tickHistory[tickHistory.length - 2];

            const lastDigit = tickHistory[tickHistory.length - 1];


            // Check if they are consecutive (difference of 1, with wrap-around consideration for 0-9, but only exact +1 or -1)

            let predictedDigit;

            if (lastDigit === prevDigit + 1 || lastDigit === prevDigit - 1) {

                // Consecutive detected! Predict the next in sequence

                const direction = lastDigit > prevDigit ? 1 : -1;

                predictedDigit = (lastDigit + direction + 10) % 10; // Modulo 10 for wrap-around (e.g., 9+1=0, 0-1=9)

                log(`Strategy: Detected consecutive pair (${prevDigit}, ${lastDigit}). Predicting next as ${predictedDigit}. Betting differs from it.`);

                return predictedDigit;

            } else {

                // No consecutive pair; fall back to most frequent in last 10

                const freq = {};

                tickHistory.forEach(d => { freq[d] = (freq[d] || 0) + 1; });

                let maxFreq = 0;

                let chosenDigit = 0;

                for (let d = 0; d <= 9; d++) {

                    if (freq[d] > maxFreq) {

                        maxFreq = freq[d];

                        chosenDigit = d;

                    } else if (freq[d] === maxFreq && d > chosenDigit) {

                        chosenDigit = d;

                    }

                }

                log(`Strategy: No consecutive pair in last two (${prevDigit}, ${lastDigit}). Falling back to most frequent digit ${chosenDigit} (freq ${maxFreq}). Betting differs from it.`);

                return chosenDigit;

            }

        }


        // Function to place a Differs trade based on strategy

        function placeTrade() {

            if (!ws || ws.readyState !== WebSocket.OPEN) {

                log('Error: Not connected to API.');

                return;

            }


            const stake = parseFloat(document.getElementById('stake').value);

            const duration = parseInt(document.getElementById('duration').value);

            const selectedSymbol = document.getElementById('symbol').value;

            const evasionDigit = getStrategyDigit(); // From new strategy


            // Check balance

            const currentBalance = parseFloat(balanceElement.textContent.split(' ')[0]);

            if (currentBalance < stake * 1.1) { // Buffer for safety

                log('Error: Insufficient balance for stake.');

                return;

            }


            const tradeParams = {

                proposal: 1,

                amount: stake,

                basis: 'stake',

                contract_type: 'DIGITDIFF', // Only Differs

                currency: 'USD', // Change to your account currency

                duration: duration,

                duration_unit: 't', // ticks

                symbol: selectedSymbol, // Dynamic symbol

                barrier: evasionDigit.toString() // Digit to differ from

            };


            log(`Placing Differs trade on ${selectedSymbol} for digit ${evasionDigit} (${duration} ticks, stake ${stake})...`);

            ws.send(JSON.stringify(tradeParams));

        }


        // Start auto-trading every 60 seconds

        function startAutoTrading() {

            if (autoTradeInterval) {

                log('Auto-trading already running.');

                return;

            }

            placeTrade(); // Initial trade

            autoTradeInterval = setInterval(placeTrade, 60000); // Every 60 seconds (adjust for 1s markets if needed)

            log('Auto-trading started with Consecutive Digit Evasion Strategy on selected symbol.');

        }


        // Stop auto-trading

        function stopAutoTrading() {

            if (autoTradeInterval) {

                clearInterval(autoTradeInterval);

                autoTradeInterval = null;

                log('Auto-trading stopped.');

            }

        }

    </script>

</body>

</html>

