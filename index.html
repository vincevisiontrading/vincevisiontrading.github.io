<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>vincevision trading by vincent omondi</title> <style> @import url('https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;700&display=swap'); body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; transition: all 0.3s ease; } h1, h2 { font-weight: 700; color: #0078d4; /* Microsoft-inspired blue */ } #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button { padding: 10px 20px; margin: 5px; background-color: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s ease; } button:hover { background-color: #005a9e; } label { display: block; margin-top: 10px; font-weight: 600; } input, select { padding: 8px; margin: 5px 0; border: 1px solid #ccc; border-radius: 4px; width: 100%; max-width: 300px; } /* Animation for popping in numbers/logs */ @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } } .log-entry { animation: popIn 0.5s ease-in-out; } .digit { display: inline-block; font-weight: bold; color: #0078d4; animation: popIn 0.5s ease-in-out, fadeOut 2s ease-in-out 1s forwards; } @keyframes fadeOut { 0% { opacity: 1; } 100% { opacity: 0; } } /* Shake animation for loss */ @keyframes shake { 0% { transform: translateX(0); } 10% { transform: translateX(-10px); } 20% { transform: translateX(10px); } 30% { transform: translateX(-10px); } 40% { transform: translateX(10px); } 50% { transform: translateX(-10px); } 60% { transform: translateX(10px); } 70% { transform: translateX(-10px); } 80% { transform: translateX(10px); } 90% { transform: translateX(-10px); } 100% { transform: translateX(0); } } .shake { animation: shake 0.5s; } /* Confetti container */ #confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 9999; } .confetti { position: absolute; width: 10px; height: 10px; background-color: green; opacity: 0.8; animation: confettiFall 3s linear forwards; } @keyframes confettiFall { 0% { transform: translateY(-100%) rotate(0deg); } 100% { transform: translateY(100vh) rotate(360deg); } } </style> </head> <body> <h1>vincevision trading by vincent omondi</h1> <p>This site auto-trades only Digits Differs using selectable sniper strategies on synthetic markets (see logs for details).</p> <label for="apiToken">API Token:</label> <input type="text" id="apiToken" placeholder="Your Deriv API Token" value="1jn9NhwnKT1Gt53"> <label for="appId">App ID:</label> <input type="text" id="appId" placeholder="Your Deriv App ID" value="107513"> <label for="symbol">Synthetic Market (Symbol):</label> <select id="symbol"> <option value="R_10">Volatility 10 (R_10)</option> <option value="R_25">Volatility 25 (R_25)</option> <option value="R_50">Volatility 50 (R_50)</option> <option value="R_75">Volatility 75 (R_75)</option> <option value="R_100">Volatility 100 (R_100)</option> <option value="1HZ500V">Boom 500 (1HZ500V)</option> <option value="1HZ1000V">Crash 1000 (1HZ1000V)</option> <option value="1HZ10V">Volatility 10 (1s) (1HZ10V)</option> <option value="1HZ25V">Volatility 25 (1s) (1HZ25V)</option> <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option> <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option> <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option> <!-- Add more symbols as needed from Deriv API docs --> </select> <label for="strategy">Sniper Strategy:</label> <select id="strategy"> <option value="consecutive">Consecutive Digit Evasion</option> <option value="rare">Rare Digit Sniper</option> <option value="parity">Parity Flip Sniper</option> <option value="momentum">Momentum Break Sniper</option> </select> <label for="stake">Stake Amount (per trade):</label> <input type="number" id="stake" value="1" min="0.35" step="0.01"> <label for="duration">Duration (ticks, 1-10):</label> <input type="number" id="duration" value="5" min="1" max="10"> <button onclick="connectToAPI()">Connect to Deriv API</button> <button onclick="startAutoTrading()">Start Auto-Trading</button> <button onclick="stopAutoTrading()">Stop Auto-Trading</button> <h2>Account Balance: <span id="balance">Not connected</span></h2> <h2>Trade Log</h2> <div id="log"></div> <div id="confetti-container"></div> <script> let ws; // WebSocket connection let autoTradeInterval; // Interval for auto-trading const logElement = document.getElementById('log'); const balanceElement = document.getElementById('balance'); const confettiContainer = document.getElementById('confetti-container'); let tickHistory = []; // Last 10 ticks' last digits let pendingProposalId = null; // To handle proposal â†’ buy // Function to log messages with animation function log(message) { const p = document.createElement('p'); p.classList.add('log-entry'); p.innerHTML = `${new Date().toLocaleTimeString()}: ${message}`; // Enhance digits in the message to pop in and disappear if (message.includes('Recent digits:')) { const parts = message.split('Recent digits: '); p.innerHTML = `${new Date().toLocaleTimeString()}: ${parts[0]}Recent digits: `; parts[1].split(', ').forEach(digit => { const span = document.createElement('span'); span.classList.add('digit'); span.textContent = digit + ' '; p.appendChild(span); }); } logElement.appendChild(p); logElement.scrollTop = logElement.scrollHeight; } // Connect to Deriv WebSocket API function connectToAPI() { const apiToken = document.getElementById('apiToken').value; const appId = document.getElementById('appId').value; const selectedSymbol = document.getElementById('symbol').value; if (!apiToken || !appId) { log('Error: Please enter API Token and App ID.'); return; } ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=' + appId); ws.onopen = () => { log('WebSocket connected.'); // Authorize with API token ws.send(JSON.stringify({ authorize: apiToken })); }; ws.onmessage = (event) => { const data = JSON.parse(event.data); if (data.error) { log('Error: ' + data.error.message); } else if (data.authorize) { log('Authorized successfully. Account: ' + data.authorize.loginid); // Subscribe to balance updates ws.send(JSON.stringify({ balance: 1, subscribe: 1 })); // Subscribe to tick stream for the selected symbol log(`Subscribing to ticks for symbol: ${selectedSymbol}`); ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 })); } else if (data.balance) { balanceElement.textContent = `${data.balance.balance} ${data.balance.currency}`; } else if (data.tick) { // Collect last digit from tick stream const lastDigit = parseInt(data.tick.quote.toString().slice(-1)); tickHistory.push(lastDigit); if (tickHistory.length > 10) tickHistory.shift(); // Keep only last 10 log(`New tick on ${data.tick.symbol}: Last digit ${lastDigit}. Recent digits: ${tickHistory.join(', ')}`); } else if (data.proposal) { // Received proposal, now buy the contract pendingProposalId = data.proposal.id; ws.send(JSON.stringify({ buy: pendingProposalId, price: data.proposal.ask_price })); } else if (data.buy) { log('Trade placed: Contract ID ' + data.buy.contract_id + ' | Buy Price: ' + data.buy.buy_price); // Subscribe to contract updates ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 })); } else if (data.proposal_open_contract) { if (data.proposal_open_contract.is_sold) { const isWin = data.proposal_open_contract.profit > 0; log('Contract closed: ' + (isWin ? 'Win' : 'Loss') + ' | Profit: ' + data.proposal_open_contract.profit); if (isWin) { showConfetti(); } else { shakeScreen(); } } } }; ws.onclose = () => { log('WebSocket disconnected.'); balanceElement.textContent = 'Disconnected'; }; ws.onerror = (error) => { log('WebSocket error: ' + error); }; } // Function to show green confetti function showConfetti() { for (let i = 0; i < 100; i++) { const confetti = document.createElement('div'); confetti.classList.add('confetti'); confetti.style.left = `${Math.random() * 100}vw`; confetti.style.animationDuration = `${Math.random() * 2 + 2}s`; confetti.style.backgroundColor = `hsl(${Math.random() * 60 + 100}, 100%, 50%)`; // Shades of green confettiContainer.appendChild(confetti); setTimeout(() => confetti.remove(), 3000); } } // Function to shake the screen function shakeScreen() { document.body.classList.add('shake'); setTimeout(() => document.body.classList.remove('shake'), 500); } // Helper: Get frequency map of digits function getDigitFreq() { const freq = {}; tickHistory.forEach(d => { freq[d] = (freq[d] || 0) + 1; }); return freq; } // Multi-Strategy Logic: Returns the digit to differ from based on selected strategy function getStrategyDigit(selectedStrategy) { if (tickHistory.length < 2) { const randomDigit = Math.floor(Math.random() * 10); log(`Insufficient tick history for ${selectedStrategy}. Defaulting to random digit: ${randomDigit}`); return randomDigit; } const freq = getDigitFreq(); switch (selectedStrategy) { case 'consecutive': // Consecutive Digit Evasion const prevDigit = tickHistory[tickHistory.length - 2]; const lastDigitC = tickHistory[tickHistory.length - 1]; let predictedDigit; if (lastDigitC === prevDigit + 1 || lastDigitC === prevDigit - 1) { const direction = lastDigitC > prevDigit ? 1 : -1; predictedDigit = (lastDigitC + direction + 10) % 10; log(`Consecutive Evasion: Pair (${prevDigit}, ${lastDigitC}). Predicting ${predictedDigit}. Differ from it.`); return predictedDigit; } else { // Fallback to most frequent let maxFreq = 0, chosen = 0; for (let d = 0; d <= 9; d++) { if (freq[d] > maxFreq || (freq[d] === maxFreq && d > chosen)) { maxFreq = freq[d]; chosen = d; } } log(`Consecutive Evasion: No pair. Most frequent ${chosen} (freq ${maxFreq}). Differ from it.`); return chosen; } case 'rare': // Rare Digit Sniper: Differ from least frequent digit let minFreq = Infinity, rareDigit = 0; for (let d = 0; d <= 9; d++) { const f = freq[d] || 0; if (f < minFreq || (f === minFreq && d < rareDigit)) { minFreq = f; rareDigit = d; } } log(`Rare Sniper: Least frequent digit ${rareDigit} (freq ${minFreq}). Differ from it.`); return rareDigit; case 'parity': // Parity Flip Sniper: If last two same parity, differ from most frequent in opposite parity const lastTwoParity = tickHistory.slice(-2).map(d => d % 2); const sameParity = lastTwoParity[0] === lastTwoParity[1]; if (sameParity) { const targetParity = 1 - lastTwoParity[1]; // Flip (0 even -> 1 odd, vice versa) let maxFreqP = 0, chosenP = targetParity === 0 ? 0 : 1; // Start with lowest in parity for (let d = targetParity; d <= 9; d += 2) { const f = freq[d] || 0; if (f > maxFreqP || (f === maxFreqP && d > chosenP)) { maxFreqP = f; chosenP = d; } } log(`Parity Flip: Last two ${lastTwoParity[1] === 0 ? 'even' : 'odd'}. Flip to ${targetParity === 0 ? 'even' : 'odd'}, most freq ${chosenP} (freq ${maxFreqP}). Differ from it.`); return chosenP; } else { // Fallback to random const randomP = Math.floor(Math.random() * 10); log(`Parity Flip: Mixed parity. Default to random ${randomP}. Differ from it.`); return randomP; } case 'momentum': // Momentum Break Sniper: Detect increasing/decreasing in last 3, differ from next if (tickHistory.length < 3) { const randomM = Math.floor(Math.random() * 10); log(`Momentum Break: Need 3 ticks. Default to random ${randomM}.`); return randomM; } const lastThree = tickHistory.slice(-3); const diff1 = lastThree[1] - lastThree[0]; const diff2 = lastThree[2] - lastThree[1]; if (diff1 === diff2 && diff1 !== 0) { // Consistent momentum (e.g., +1 each time) const predictedM = (lastThree[2] + diff2 + 10) % 10; log(`Momentum Break: Sequence ${lastThree.join('-')} (diff ${diff1}). Predicting break from ${predictedM}. Differ from it.`); return predictedM; } else { // Fallback to average digit const avg = Math.floor(tickHistory.reduce((a, b) => a + b, 0) / tickHistory.length); log(`Momentum Break: No consistent momentum. Average digit ${avg}. Differ from it.`); return avg; } default: return Math.floor(Math.random() * 10); // Fallback } } // Function to place a Differs trade based on strategy function placeTrade() { if (!ws || ws.readyState !== WebSocket.OPEN) { log('Error: Not connected to API.'); return; } const stake = parseFloat(document.getElementById('stake').value); const duration = parseInt(document.getElementById('duration').value); const selectedSymbol = document.getElementById('symbol').value; const selectedStrategy = document.getElementById('strategy').value; const evasionDigit = getStrategyDigit(selectedStrategy); // Check balance const currentBalance = parseFloat(balanceElement.textContent.split(' ')[0]); if (currentBalance < stake * 1.1) { // Buffer for safety log('Error: Insufficient balance for stake.'); return; } const tradeParams = { proposal: 1, amount: stake, basis: 'stake', contract_type: 'DIGITDIFF', // Only Differs currency: 'USD', // Change to your account currency duration: duration, duration_unit: 't', // ticks symbol: selectedSymbol, // Dynamic symbol barrier: evasionDigit.toString() // Digit to differ from }; log(`Placing Differs trade on ${selectedSymbol} for digit ${evasionDigit} (${selectedStrategy} strategy, ${duration} ticks, stake ${stake})...`); ws.send(JSON.stringify(tradeParams)); } // Start auto-trading every 60 seconds function startAutoTrading() { if (autoTradeInterval) { log('Auto-trading already running.'); return; } placeTrade(); // Initial trade autoTradeInterval = setInterval(placeTrade, 60000); // Every 60 seconds (adjust for faster markets) const selectedStrategy = document.getElementById('strategy').value; log(`Auto-trading started with ${selectedStrategy} Sniper Strategy on selected symbol.`); } // Stop auto-trading function stopAutoTrading() { if (autoTradeInterval) { clearInterval(autoTradeInterval); autoTradeInterval = null; log('Auto-trading stopped.'); } } </script> </body> </html>
Â  Â  Â  Â  <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option>

Â  Â  Â  Â  <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option>

Â  Â  Â  Â  <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option>

Â  Â  Â  Â  <!-- Add more symbols as needed from Deriv API docs -->

Â  Â  </select>

Â  Â  

Â  Â  <label for="stake">Stake Amount (per trade):</label>

Â  Â  <input type="number" id="stake" value="1" min="0.35" step="0.01">

Â  Â  

Â  Â  <label for="duration">Duration (ticks, 1-10):</label>

Â  Â  <input type="number" id="duration" value="5" min="1" max="10">

Â  Â  

Â  Â  <button onclick="connectToAPI()">Connect to Deriv API</button>

Â  Â  <button onclick="startAutoTrading()">Start Auto-Trading</button>

Â  Â  <button onclick="stopAutoTrading()">Stop Auto-Trading</button>

Â  Â  

Â  Â  <h2>Account Balance: <span id="balance">Not connected</span></h2>

Â  Â  <h2>Trade Log</h2>

Â  Â  <div id="log"></div>


Â  Â  <script>

Â  Â  Â  Â  let ws; // WebSocket connection

Â  Â  Â  Â  let autoTradeInterval; // Interval for auto-trading

Â  Â  Â  Â  const logElement = document.getElementById('log');

Â  Â  Â  Â  const balanceElement = document.getElementById('balance');

Â  Â  Â  Â  let tickHistory = []; // Last 10 ticks' last digits

Â  Â  Â  Â  let pendingProposalId = null; // To handle proposal â†’ buy


Â  Â  Â  Â  // Function to log messages

Â  Â  Â  Â  function log(message) {

Â  Â  Â  Â  Â  Â  logElement.innerHTML += `<p>${new Date().toLocaleTimeString()}: ${message}</p>`;

Â  Â  Â  Â  Â  Â  logElement.scrollTop = logElement.scrollHeight;

Â  Â  Â  Â  }


Â  Â  Â  Â  // Connect to Deriv WebSocket API

Â  Â  Â  Â  function connectToAPI() {

Â  Â  Â  Â  Â  Â  const apiToken = document.getElementById('apiToken').value;

Â  Â  Â  Â  Â  Â  const appId = document.getElementById('appId').value;

Â  Â  Â  Â  Â  Â  const selectedSymbol = document.getElementById('symbol').value;


Â  Â  Â  Â  Â  Â  if (!apiToken || !appId) {

Â  Â  Â  Â  Â  Â  Â  Â  log('Error: Please enter API Token and App ID.');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=' + appId);


Â  Â  Â  Â  Â  Â  ws.onopen = () => {

Â  Â  Â  Â  Â  Â  Â  Â  log('WebSocket connected.');

Â  Â  Â  Â  Â  Â  Â  Â  // Authorize with API token

Â  Â  Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify({ authorize: apiToken }));

Â  Â  Â  Â  Â  Â  };


Â  Â  Â  Â  Â  Â  ws.onmessage = (event) => {

Â  Â  Â  Â  Â  Â  Â  Â  const data = JSON.parse(event.data);

Â  Â  Â  Â  Â  Â  Â  Â  if (data.error) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log('Error: ' + data.error.message);

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.authorize) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log('Authorized successfully. Account: ' + data.authorize.loginid);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Subscribe to balance updates

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Subscribe to tick stream for the selected symbol

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log(`Subscribing to ticks for symbol: ${selectedSymbol}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 }));

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.balance) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  balanceElement.textContent = `${data.balance.balance} ${data.balance.currency}`;

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.tick) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Collect last digit from tick stream

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const lastDigit = parseInt(data.tick.quote.toString().slice(-1));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tickHistory.push(lastDigit);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (tickHistory.length > 10) tickHistory.shift(); // Keep only last 10

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log(`New tick on ${data.tick.symbol}: Last digit ${lastDigit}. Recent digits: ${tickHistory.join(', ')}`);

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.proposal) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Received proposal, now buy the contract

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pendingProposalId = data.proposal.id;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify({ buy: pendingProposalId, price: data.proposal.ask_price }));

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.buy) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log('Trade placed: Contract ID ' + data.buy.contract_id + ' | Buy Price: ' + data.buy.buy_price);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Subscribe to contract updates

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 }));

Â  Â  Â  Â  Â  Â  Â  Â  } else if (data.proposal_open_contract) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (data.proposal_open_contract.is_sold) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  log('Contract closed: ' + (data.proposal_open_contract.profit > 0 ? 'Win' : 'Loss') + ' | Profit: ' + data.proposal_open_contract.profit);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  };


Â  Â  Â  Â  Â  Â  ws.onclose = () => {

Â  Â  Â  Â  Â  Â  Â  Â  log('WebSocket disconnected.');

Â  Â  Â  Â  Â  Â  Â  Â  balanceElement.textContent = 'Disconnected';

Â  Â  Â  Â  Â  Â  };


Â  Â  Â  Â  Â  Â  ws.onerror = (error) => {

Â  Â  Â  Â  Â  Â  Â  Â  log('WebSocket error: ' + error);

Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  }


Â  Â  Â  Â  // New Custom Strategy: Consecutive Digit Evasion - Detect two consecutive digits and evade the next in sequence

Â  Â  Â  Â  function getStrategyDigit() {

Â  Â  Â  Â  Â  Â  if (tickHistory.length < 2) {

Â  Â  Â  Â  Â  Â  Â  Â  // Not enough history, default to random

Â  Â  Â  Â  Â  Â  Â  Â  const randomDigit = Math.floor(Math.random() * 10);

Â  Â  Â  Â  Â  Â  Â  Â  log(`Insufficient tick history. Defaulting to differ from random digit: ${randomDigit}`);

Â  Â  Â  Â  Â  Â  Â  Â  return randomDigit;

Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // Get the last two digits

Â  Â  Â  Â  Â  Â  const prevDigit = tickHistory[tickHistory.length - 2];

Â  Â  Â  Â  Â  Â  const lastDigit = tickHistory[tickHistory.length - 1];


Â  Â  Â  Â  Â  Â  // Check if they are consecutive (difference of 1, with wrap-around consideration for 0-9, but only exact +1 or -1)

Â  Â  Â  Â  Â  Â  let predictedDigit;

Â  Â  Â  Â  Â  Â  if (lastDigit === prevDigit + 1 || lastDigit === prevDigit - 1) {

Â  Â  Â  Â  Â  Â  Â  Â  // Consecutive detected! Predict the next in sequence

Â  Â  Â  Â  Â  Â  Â  Â  const direction = lastDigit > prevDigit ? 1 : -1;

Â  Â  Â  Â  Â  Â  Â  Â  predictedDigit = (lastDigit + direction + 10) % 10; // Modulo 10 for wrap-around (e.g., 9+1=0, 0-1=9)

Â  Â  Â  Â  Â  Â  Â  Â  log(`Strategy: Detected consecutive pair (${prevDigit}, ${lastDigit}). Predicting next as ${predictedDigit}. Betting differs from it.`);

Â  Â  Â  Â  Â  Â  Â  Â  return predictedDigit;

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  // No consecutive pair; fall back to most frequent in last 10

Â  Â  Â  Â  Â  Â  Â  Â  const freq = {};

Â  Â  Â  Â  Â  Â  Â  Â  tickHistory.forEach(d => { freq[d] = (freq[d] || 0) + 1; });

Â  Â  Â  Â  Â  Â  Â  Â  let maxFreq = 0;

Â  Â  Â  Â  Â  Â  Â  Â  let chosenDigit = 0;

Â  Â  Â  Â  Â  Â  Â  Â  for (let d = 0; d <= 9; d++) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (freq[d] > maxFreq) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxFreq = freq[d];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chosenDigit = d;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (freq[d] === maxFreq && d > chosenDigit) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  chosenDigit = d;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  log(`Strategy: No consecutive pair in last two (${prevDigit}, ${lastDigit}). Falling back to most frequent digit ${chosenDigit} (freq ${maxFreq}). Betting differs from it.`);

Â  Â  Â  Â  Â  Â  Â  Â  return chosenDigit;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }


Â  Â  Â  Â  // Function to place a Differs trade based on strategy

Â  Â  Â  Â  function placeTrade() {

Â  Â  Â  Â  Â  Â  if (!ws || ws.readyState !== WebSocket.OPEN) {

Â  Â  Â  Â  Â  Â  Â  Â  log('Error: Not connected to API.');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  const stake = parseFloat(document.getElementById('stake').value);

Â  Â  Â  Â  Â  Â  const duration = parseInt(document.getElementById('duration').value);

Â  Â  Â  Â  Â  Â  const selectedSymbol = document.getElementById('symbol').value;

Â  Â  Â  Â  Â  Â  const evasionDigit = getStrategyDigit(); // From new strategy


Â  Â  Â  Â  Â  Â  // Check balance

Â  Â  Â  Â  Â  Â  const currentBalance = parseFloat(balanceElement.textContent.split(' ')[0]);

Â  Â  Â  Â  Â  Â  if (currentBalance < stake * 1.1) { // Buffer for safety

Â  Â  Â  Â  Â  Â  Â  Â  log('Error: Insufficient balance for stake.');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  const tradeParams = {

Â  Â  Â  Â  Â  Â  Â  Â  proposal: 1,

Â  Â  Â  Â  Â  Â  Â  Â  amount: stake,

Â  Â  Â  Â  Â  Â  Â  Â  basis: 'stake',

Â  Â  Â  Â  Â  Â  Â  Â  contract_type: 'DIGITDIFF', // Only Differs

Â  Â  Â  Â  Â  Â  Â  Â  currency: 'USD', // Change to your account currency

Â  Â  Â  Â  Â  Â  Â  Â  duration: duration,

Â  Â  Â  Â  Â  Â  Â  Â  duration_unit: 't', // ticks

Â  Â  Â  Â  Â  Â  Â  Â  symbol: selectedSymbol, // Dynamic symbol

Â  Â  Â  Â  Â  Â  Â  Â  barrier: evasionDigit.toString() // Digit to differ from

Â  Â  Â  Â  Â  Â  };


Â  Â  Â  Â  Â  Â  log(`Placing Differs trade on ${selectedSymbol} for digit ${evasionDigit} (${duration} ticks, stake ${stake})...`);

Â  Â  Â  Â  Â  Â  ws.send(JSON.stringify(tradeParams));

Â  Â  Â  Â  }


Â  Â  Â  Â  // Start auto-trading every 60 seconds

Â  Â  Â  Â  function startAutoTrading() {

Â  Â  Â  Â  Â  Â  if (autoTradeInterval) {

Â  Â  Â  Â  Â  Â  Â  Â  log('Auto-trading already running.');

Â  Â  Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  placeTrade(); // Initial trade

Â  Â  Â  Â  Â  Â  autoTradeInterval = setInterval(placeTrade, 60000); // Every 60 seconds (adjust for 1s markets if needed)

Â  Â  Â  Â  Â  Â  log('Auto-trading started with Consecutive Digit Evasion Strategy on selected symbol.');

Â  Â  Â  Â  }


Â  Â  Â  Â  // Stop auto-trading

Â  Â  Â  Â  function stopAutoTrading() {

Â  Â  Â  Â  Â  Â  if (autoTradeInterval) {

Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(autoTradeInterval);

Â  Â  Â  Â  Â  Â  Â  Â  autoTradeInterval = null;

Â  Â  Â  Â  Â  Â  Â  Â  log('Auto-trading stopped.');

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  </script>

</body>

</html>

