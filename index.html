<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Deriv Auto Trader - Differs Multi-Strategy</title> <style> body { font-family: Arial, sans-serif; margin: 20px; } #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; } button { padding: 10px; margin: 5px; } label { display: block; margin-top: 10px; } </style> </head> <body> <h1>Deriv Auto Trader - Differs Only with Multiple Sniper Strategies</h1> <p>This site auto-trades only Digits Differs using selectable sniper strategies on synthetic markets (see logs for details).</p> <label for="apiToken">API Token:</label> <input type="text" id="apiToken" placeholder="Your Deriv API Token" value="1jn9NhwnKT1Gt53"> <label for="appId">App ID:</label> <input type="text" id="appId" placeholder="Your Deriv App ID" value="107513"> <label for="symbol">Synthetic Market (Symbol):</label> <select id="symbol"> <option value="R_10">Volatility 10 (R_10)</option> <option value="R_25">Volatility 25 (R_25)</option> <option value="R_50">Volatility 50 (R_50)</option> <option value="R_75">Volatility 75 (R_75)</option> <option value="R_100">Volatility 100 (R_100)</option> <option value="1HZ500V">Boom 500 (1HZ500V)</option> <option value="1HZ1000V">Crash 1000 (1HZ1000V)</option> <option value="1HZ10V">Volatility 10 (1s) (1HZ10V)</option> <option value="1HZ25V">Volatility 25 (1s) (1HZ25V)</option> <option value="1HZ50V">Volatility 50 (1s) (1HZ50V)</option> <option value="1HZ75V">Volatility 75 (1s) (1HZ75V)</option> <option value="1HZ100V">Volatility 100 (1s) (1HZ100V)</option> <!-- Add more symbols as needed from Deriv API docs --> </select> <label for="strategy">Sniper Strategy:</label> <select id="strategy"> <option value="consecutive">Consecutive Digit Evasion</option> <option value="rare">Rare Digit Sniper</option> <option value="parity">Parity Flip Sniper</option> <option value="momentum">Momentum Break Sniper</option> </select> <label for="stake">Stake Amount (per trade):</label> <input type="number" id="stake" value="1" min="0.35" step="0.01"> <label for="duration">Duration (ticks, 1-10):</label> <input type="number" id="duration" value="5" min="1" max="10"> <button onclick="connectToAPI()">Connect to Deriv API</button> <button onclick="startAutoTrading()">Start Auto-Trading</button> <button onclick="stopAutoTrading()">Stop Auto-Trading</button> <h2>Account Balance: <span id="balance">Not connected</span></h2> <h2>Trade Log</h2> <div id="log"></div> <script> let ws; // WebSocket connection let autoTradeInterval; // Interval for auto-trading const logElement = document.getElementById('log'); const balanceElement = document.getElementById('balance'); let tickHistory = []; // Last 10 ticks' last digits let pendingProposalId = null; // To handle proposal â†’ buy // Function to log messages function log(message) { logElement.innerHTML += `<p>${new Date().toLocaleTimeString()}: ${message}</p>`; logElement.scrollTop = logElement.scrollHeight; } // Connect to Deriv WebSocket API function connectToAPI() { const apiToken = document.getElementById('apiToken').value; const appId = document.getElementById('appId').value; const selectedSymbol = document.getElementById('symbol').value; if (!apiToken || !appId) { log('Error: Please enter API Token and App ID.'); return; } ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=' + appId); ws.onopen = () => { log('WebSocket connected.'); // Authorize with API token ws.send(JSON.stringify({ authorize: apiToken })); }; ws.onmessage = (event) => { const data = JSON.parse(event.data); if (data.error) { log('Error: ' + data.error.message); } else if (data.authorize) { log('Authorized successfully. Account: ' + data.authorize.loginid); // Subscribe to balance updates ws.send(JSON.stringify({ balance: 1, subscribe: 1 })); // Subscribe to tick stream for the selected symbol log(`Subscribing to ticks for symbol: ${selectedSymbol}`); ws.send(JSON.stringify({ ticks: selectedSymbol, subscribe: 1 })); } else if (data.balance) { balanceElement.textContent = `${data.balance.balance} ${data.balance.currency}`; } else if (data.tick) { // Collect last digit from tick stream const lastDigit = parseInt(data.tick.quote.toString().slice(-1)); tickHistory.push(lastDigit); if (tickHistory.length > 10) tickHistory.shift(); // Keep only last 10 log(`New tick on ${data.tick.symbol}: Last digit ${lastDigit}. Recent digits: ${tickHistory.join(', ')}`); } else if (data.proposal) { // Received proposal, now buy the contract pendingProposalId = data.proposal.id; ws.send(JSON.stringify({ buy: pendingProposalId, price: data.proposal.ask_price })); } else if (data.buy) { log('Trade placed: Contract ID ' + data.buy.contract_id + ' | Buy Price: ' + data.buy.buy_price); // Subscribe to contract updates ws.send(JSON.stringify({ proposal_open_contract: 1, contract_id: data.buy.contract_id, subscribe: 1 })); } else if (data.proposal_open_contract) { if (data.proposal_open_contract.is_sold) { log('Contract closed: ' + (data.proposal_open_contract.profit > 0 ? 'Win' : 'Loss') + ' | Profit: ' + data.proposal_open_contract.profit); } } }; ws.onclose = () => { log('WebSocket disconnected.'); balanceElement.textContent = 'Disconnected'; }; ws.onerror = (error) => { log('WebSocket error: ' + error); }; } // Helper: Get frequency map of digits function getDigitFreq() { const freq = {}; tickHistory.forEach(d => { freq[d] = (freq[d] || 0) + 1; }); return freq; } // Multi-Strategy Logic: Returns the digit to differ from based on selected strategy function getStrategyDigit(selectedStrategy) { if (tickHistory.length < 2) { const randomDigit = Math.floor(Math.random() * 10); log(`Insufficient tick history for ${selectedStrategy}. Defaulting to random digit: ${randomDigit}`); return randomDigit; } const freq = getDigitFreq(); switch (selectedStrategy) { case 'consecutive': // Consecutive Digit Evasion const prevDigit = tickHistory[tickHistory.length - 2]; const lastDigitC = tickHistory[tickHistory.length - 1]; let predictedDigit; if (lastDigitC === prevDigit + 1 || lastDigitC === prevDigit - 1) { const direction = lastDigitC > prevDigit ? 1 : -1; predictedDigit = (lastDigitC + direction + 10) % 10; log(`Consecutive Evasion: Pair (${prevDigit}, ${lastDigitC}). Predicting ${predictedDigit}. Differ from it.`); return predictedDigit; } else { // Fallback to most frequent let maxFreq = 0, chosen = 0; for (let d = 0; d <= 9; d++) { if (freq[d] > maxFreq || (freq[d] === maxFreq && d > chosen)) { maxFreq = freq[d]; chosen = d; } } log(`Consecutive Evasion: No pair. Most frequent ${chosen} (freq ${maxFreq}). Differ from it.`); return chosen; } case 'rare': // Rare Digit Sniper: Differ from least frequent digit let minFreq = Infinity, rareDigit = 0; for (let d = 0; d <= 9; d++) { const f = freq[d] || 0; if (f < minFreq || (f === minFreq && d < rareDigit)) { minFreq = f; rareDigit = d; } } log(`Rare Sniper: Least frequent digit ${rareDigit} (freq ${minFreq}). Differ from it.`); return rareDigit; case 'parity': // Parity Flip Sniper: If last two same parity, differ from most frequent in opposite parity const lastTwoParity = tickHistory.slice(-2).map(d => d % 2); const sameParity = lastTwoParity[0] === lastTwoParity[1]; if (sameParity) { const targetParity = 1 - lastTwoParity[1]; // Flip (0 even -> 1 odd, vice versa) let maxFreqP = 0, chosenP = targetParity === 0 ? 0 : 1; // Start with lowest in parity for (let d = targetParity; d <= 9; d += 2) { const f = freq[d] || 0; if (f > maxFreqP || (f === maxFreqP && d > chosenP)) { maxFreqP = f; chosenP = d; } } log(`Parity Flip: Last two ${lastTwoParity[1] === 0 ? 'even' : 'odd'}. Flip to ${targetParity === 0 ? 'even' : 'odd'}, most freq ${chosenP} (freq ${maxFreqP}). Differ from it.`); return chosenP; } else { // Fallback to random const randomP = Math.floor(Math.random() * 10); log(`Parity Flip: Mixed parity. Default to random ${randomP}. Differ from it.`); return randomP; } case 'momentum': // Momentum Break Sniper: Detect increasing/decreasing in last 3, differ from next if (tickHistory.length < 3) { const randomM = Math.floor(Math.random() * 10); log(`Momentum Break: Need 3 ticks. Default to random ${randomM}.`); return randomM; } const lastThree = tickHistory.slice(-3); const diff1 = lastThree[1] - lastThree[0]; const diff2 = lastThree[2] - lastThree[1]; if (diff1 === diff2 && diff1 !== 0) { // Consistent momentum (e.g., +1 each time) const predictedM = (lastThree[2] + diff2 + 10) % 10; log(`Momentum Break: Sequence ${lastThree.join('-')} (diff ${diff1}). Predicting break from ${predictedM}. Differ from it.`); return predictedM; } else { // Fallback to average digit const avg = Math.floor(tickHistory.reduce((a, b) => a + b, 0) / tickHistory.length); log(`Momentum Break: No consistent momentum. Average digit ${avg}. Differ from it.`); return avg; } default: return Math.floor(Math.random() * 10); // Fallback } } // Function to place a Differs trade based on strategy function placeTrade() { if (!ws || ws.readyState !== WebSocket.OPEN) { log('Error: Not connected to API.'); return; } const stake = parseFloat(document.getElementById('stake').value); const duration = parseInt(document.getElementById('duration').value); const selectedSymbol = document.getElementById('symbol').value; const selectedStrategy = document.getElementById('strategy').value; const evasionDigit = getStrategyDigit(selectedStrategy); // Check balance const currentBalance = parseFloat(balanceElement.textContent.split(' ')[0]); if (currentBalance < stake * 1.1) { // Buffer for safety log('Error: Insufficient balance for stake.'); return; } const tradeParams = { proposal: 1, amount: stake, basis: 'stake', contract_type: 'DIGITDIFF', // Only Differs currency: 'USD', // Change to your account currency duration: duration, duration_unit: 't', // ticks symbol: selectedSymbol, // Dynamic symbol barrier: evasionDigit.toString() // Digit to differ from }; log(`Placing Differs trade on ${selectedSymbol} for digit ${evasionDigit} (${selectedStrategy} strategy, ${duration} ticks, stake ${stake})...`); ws.send(JSON.stringify(tradeParams)); } // Start auto-trading every 60 seconds function startAutoTrading() { if (autoTradeInterval) { log('Auto-trading already running.'); return; } placeTrade(); // Initial trade autoTradeInterval = setInterval(placeTrade, 60000); // Every 60 seconds (adjust for faster markets) const selectedStrategy = document.getElementById('strategy').value; log(`Auto-trading started with ${selectedStrategy} Sniper Strategy on selected symbol.`); } // Stop auto-trading function stopAutoTrading() { if (autoTradeInterval) { clearInterval(autoTradeInterval); autoTradeInterval = null; log('Auto-trading stopped.'); } } </script> </body> </html>
